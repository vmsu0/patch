diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index d35e3b8..4f25015 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -604,12 +604,6 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
  */
 void *devpts_get_priv(struct dentry *dentry)
 {
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-	if (likely(ksu_devpts_hook)) {
-		ksu_handle_devpts(dentry->d_inode);
-	}
-#endif
-
 	if (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)
 		return NULL;
 	return dentry->d_fsdata;
diff --git a/fs/exec.c b/fs/exec.c
index 399cc9a..d50d658 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1904,21 +1904,11 @@ out_ret:
 	return retval;
 }
 
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-extern bool susfs_is_sus_su_hooks_enabled __read_mostly;
-extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr, void *argv,
-				void *envp, int *flags);
-#endif
-
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-	if (susfs_is_sus_su_hooks_enabled)
-		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
-#endif
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
 
diff --git a/fs/namespace.c b/fs/namespace.c
index d95b481..9a5767a 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -30,7 +30,7 @@
 #include <uapi/linux/mount.h>
 #include <linux/fs_context.h>
 #include <linux/shmem_fs.h>
-#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_TRY_UMOUNT)
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 #include <linux/susfs_def.h>
 #endif
 
@@ -39,27 +39,13 @@
 
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 extern bool susfs_is_current_ksu_domain(void);
-extern bool susfs_is_current_zygote_domain(void);
 extern bool susfs_is_boot_completed_triggered;
 
-static DEFINE_IDA(susfs_ksu_mnt_id_ida);
 static DEFINE_IDA(susfs_ksu_mnt_group_ida);
+static atomic64_t susfs_ksu_mounts = ATOMIC64_INIT(0);
 
 #define CL_COPY_MNT_NS BIT(25) /* used by copy_mnt_ns() */
-#endif
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-extern void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname);
-bool susfs_is_auto_add_sus_ksu_default_mount_enabled = true;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-extern void susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target);
-bool susfs_is_auto_add_sus_bind_mount_enabled = true;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-extern void susfs_auto_add_try_umount_for_bind_mount(struct path *path);
-bool susfs_is_auto_add_try_umount_for_bind_mount_enabled = true;
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 
 /* Maximum number of mounts in a mount namespace */
 unsigned int sysctl_mount_max __read_mostly = 100000;
@@ -1130,8 +1116,10 @@ struct vfsmount *vfs_create_mount(struct fs_context *fc)
 	if (susfs_is_boot_completed_triggered) {
 		goto orig_flow;
 	}
-	if (susfs_is_current_ksu_domain()) {
+	// We keep checking for ksu process only until boot-completed stage is triggered
+	if (!susfs_is_boot_completed_triggered && susfs_is_current_ksu_domain()) {
 		mnt = susfs_alloc_sus_vfsmnt(fc->source ?: "none");
+		atomic64_add(1, &susfs_ksu_mounts);
 		goto bypass_orig_flow;
 	}
 orig_flow:
@@ -2586,23 +2574,6 @@ static int do_loopback(struct path *path, const char *old_name,
 		umount_tree(mnt, UMOUNT_SYNC);
 		unlock_mount_hash();
 	}
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
-	// Check if bind mounted path should be hidden and umounted automatically.
-	// And we target only process with ksu domain.
-	if (susfs_is_current_ksu_domain()) {
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT)
-		if (susfs_is_auto_add_sus_bind_mount_enabled) {
-			susfs_auto_add_sus_bind_mount(old_name, &old_path);
-		}
-#endif
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
-		if (susfs_is_auto_add_try_umount_for_bind_mount_enabled) {
-			susfs_auto_add_try_umount_for_bind_mount(path);
-		}
-#endif
-	}
-#endif // #if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
-
 out2:
 	unlock_mount(mp);
 out:
@@ -3450,12 +3421,6 @@ long do_mount(const char *dev_name, const char __user *dir_name,
 		retval = do_new_mount(&path, type_page, sb_flags, mnt_flags,
 				      dev_name, data_page);
 dput_out:
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT) && defined(CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT)
-	// Just for the compatibility of Magic Mount KernelSU
-	if (!susfs_is_boot_completed_triggered && !retval && susfs_is_auto_add_sus_ksu_default_mount_enabled && susfs_is_current_ksu_domain()) {
-		susfs_auto_add_sus_ksu_default_mount(dir_name);
-	}
-#endif
 	path_put(&path);
 	return retval;
 }
@@ -3879,12 +3844,6 @@ out_to:
 	path_put(&to_path);
 out_from:
 	path_put(&from_path);
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-	// For Legacy KSU mount scheme
-	if (!susfs_is_boot_completed_triggered && !ret && susfs_is_auto_add_sus_ksu_default_mount_enabled && susfs_is_current_ksu_domain()) {
-		susfs_auto_add_sus_ksu_default_mount(to_pathname);
-	}
-#endif
 
 	return ret;
 }
@@ -4354,6 +4313,11 @@ void susfs_reorder_mnt_id(void) {
 		return;
 	}
 
+	// Do not reorder the mnt_id if there is no any ksu mount at all
+	if (atomic64_read(&susfs_ksu_mounts) == 0) {
+		return;
+	}
+
 	get_mnt_ns(mnt_ns);
 	first_mnt_id = list_first_entry(&mnt_ns->list, struct mount, mnt_list)->mnt_id;
 	list_for_each_entry(mnt, &mnt_ns->list, mnt_list) {
@@ -4361,22 +4325,9 @@ void susfs_reorder_mnt_id(void) {
 		if (mnt->mnt_id == DEFAULT_KSU_MNT_ID) {
 			continue;
 		}
-		mnt->mnt.susfs_mnt_id_backup = mnt->mnt_id;
-		mnt->mnt_id = first_mnt_id++;
+		WRITE_ONCE(mnt->mnt.susfs_mnt_id_backup, READ_ONCE(mnt->mnt_id));
+		WRITE_ONCE(mnt->mnt_id, first_mnt_id++);
 	}
 	put_mnt_ns(mnt_ns);
 }
 #endif
-#ifdef CONFIG_KSU_SUSFS
-bool susfs_is_mnt_devname_ksu(struct path *path) {
-	struct mount *mnt;
-
-	if (path && path->mnt) {
-		mnt = real_mount(path->mnt);
-		if (mnt && mnt->mnt_devname && !strcmp(mnt->mnt_devname, "KSU")) {
-			return true;
-		}
-	}
-	return false;
-}
-#endif
diff --git a/fs/open.c b/fs/open.c
index e902bc0..4d475e4 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -346,12 +346,6 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  * switching the fsuid/fsgid around to the real ones.
  */
 
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-extern bool susfs_is_sus_su_hooks_enabled __read_mostly;
-extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
-			int *flags);
-#endif
-
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index e40c649..7561e50 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -22,7 +22,7 @@
 #include "internal.h"
 
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-bool susfs_hide_sus_mnts_for_all_procs = true; // hide sus mounts for all processes by default
+extern bool susfs_hide_sus_mnts_for_all_procs;
 #endif
 
 static __poll_t mounts_poll(struct file *file, poll_table *wait)
diff --git a/fs/stat.c b/fs/stat.c
index 4e750f6..d07dc7c 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -184,11 +184,6 @@ EXPORT_SYMBOL(vfs_statx_fd);
  * 0 will be returned on success, and a -ve error code if unsuccessful.
  */
 
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-extern bool susfs_is_sus_su_hooks_enabled __read_mostly;
-extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
-#endif
-
 int vfs_statx(int dfd, const char __user *filename, int flags,
 	      struct kstat *stat, u32 request_mask)
 {
diff --git a/fs/statfs.c b/fs/statfs.c
index ca59fd5..7647d9c 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -254,11 +254,6 @@ static int vfs_ustat(dev_t dev, struct kstatfs *sbuf)
 	if (!s)
 		return -EINVAL;
 
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	if (unlikely(s->s_root->d_inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		return -EINVAL;
-	}
-#endif
 	err = statfs_by_dentry(s->s_root, sbuf);
 	drop_super(s);
 	return err;
diff --git a/fs/susfs.c b/fs/susfs.c
index bf8e9cc..c66103d 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -17,13 +17,7 @@
 #include <linux/susfs.h>
 #include "mount.h"
 
-static spinlock_t susfs_spin_lock;
-
 extern bool susfs_is_current_ksu_domain(void);
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-extern void try_umount(const char *mnt, bool check_mnt, int flags, uid_t uid);
-#endif
-extern bool susfs_is_avc_log_spoofing_enabled;
 
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
 bool susfs_is_log_enabled __read_mostly = true;
@@ -44,304 +38,227 @@ bool susfs_starts_with(const char *str, const char *prefix) {
 
 /* sus_path */
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_path);
 static LIST_HEAD(LH_SUS_PATH_LOOP);
 static LIST_HEAD(LH_SUS_PATH_ANDROID_DATA);
 static LIST_HEAD(LH_SUS_PATH_SDCARD);
-static struct st_android_data_path android_data_path = {0};
-static struct st_sdcard_path sdcard_path = {0};
+static struct st_external_dir android_data_path = {0};
+static struct st_external_dir sdcard_path = {0};
 const struct qstr susfs_fake_qstr_name = QSTR_INIT("..5.u.S", 7); // used to re-test the dcache lookup, make sure you don't have file named like this!!
 
-int susfs_set_i_state_on_external_dir(char __user* user_info, int cmd) {
+void susfs_set_i_state_on_external_dir(void __user **user_info) {
 	struct path path;
-	int err = 0;
 	struct inode *inode = NULL;
-	char *info = kmalloc(SUSFS_MAX_LEN_PATHNAME, GFP_KERNEL);
-	char *tmp_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	char *resolved_pathname = NULL;
-
-	if (!info) {
-		err = -ENOMEM;
-		return err;
-	}
+	static struct st_external_dir info = {0};
 
-	if (!tmp_buf) {
-		err = -ENOMEM;
-		goto out_kfree_info;
+	if (copy_from_user(&info, (struct st_external_dir __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	err = strncpy_from_user(info, user_info, SUSFS_MAX_LEN_PATHNAME-1);
-	if (err < 0) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		goto out_kfree_tmp_buf;
-	}
-
-	err = kern_path(info, LOOKUP_FOLLOW, &path);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", info);
-		goto out_kfree_tmp_buf;
-	}
-
-	resolved_pathname = d_path(&path, tmp_buf, PAGE_SIZE);
-	if (!resolved_pathname) {
-		err = -ENOMEM;
-		goto out_path_put_path;
+	info.err = kern_path(info.target_pathname, LOOKUP_FOLLOW, &path);
+	if (info.err) {
+		SUSFS_LOGE("Failed opening file '%s'\n", info.target_pathname);
+		goto out_copy_to_user;
 	}
 
 	inode = d_inode(path.dentry);
 	if (!inode) {
-		err = -EINVAL;
+		info.err = -EINVAL;
 		goto out_path_put_path;
 	}
 	
-	if (cmd == CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH) {
+	if (info.cmd == CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH) {
 		spin_lock(&inode->i_lock);
 		set_bit(AS_FLAGS_ANDROID_DATA_ROOT_DIR, &inode->i_mapping->flags);
 		spin_unlock(&inode->i_lock);
-		strncpy(android_data_path.pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME-1);
+		strncpy(android_data_path.target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME-1);
 		android_data_path.is_inited = true;
+		android_data_path.cmd = CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH;
 		SUSFS_LOGI("Set android data root dir: '%s', i_mapping: '0x%p'\n",
-			android_data_path.pathname, inode->i_mapping);
-	} else if (cmd == CMD_SUSFS_SET_SDCARD_ROOT_PATH) {
+			android_data_path.target_pathname, inode->i_mapping);
+		info.err = 0;
+	} else if (info.cmd == CMD_SUSFS_SET_SDCARD_ROOT_PATH) {
 		spin_lock(&inode->i_lock);
 		set_bit(AS_FLAGS_SDCARD_ROOT_DIR, &inode->i_mapping->flags);
 		spin_unlock(&inode->i_lock);
-		strncpy(sdcard_path.pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME-1);
+		strncpy(sdcard_path.target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME-1);
 		sdcard_path.is_inited = true;
+		sdcard_path.cmd = CMD_SUSFS_SET_SDCARD_ROOT_PATH;
 		SUSFS_LOGI("Set sdcard root dir: '%s', i_mapping: '0x%p'\n",
-			sdcard_path.pathname, inode->i_mapping);
+			sdcard_path.target_pathname, inode->i_mapping);
+		info.err = 0;
 	} else {
-		err = -EINVAL;
+		info.err = -EINVAL;
 	}
 
 out_path_put_path:
 	path_put(&path);
-out_kfree_tmp_buf:
-	kfree(tmp_buf);
-out_kfree_info:
-	kfree(info);
-	return err;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_external_dir __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	if (info.cmd == CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH) {
+		SUSFS_LOGI("CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH -> ret: %d\n", info.err);
+	} else if (info.cmd == CMD_SUSFS_SET_SDCARD_ROOT_PATH) {
+		SUSFS_LOGI("CMD_SUSFS_SET_SDCARD_ROOT_PATH -> ret: %d\n", info.err);
+	}
 }
 
-int susfs_add_sus_path(struct st_susfs_sus_path* __user user_info) {
-	struct st_susfs_sus_path_list *cursor = NULL, *temp = NULL;
+void susfs_add_sus_path(void __user **user_info) {
 	struct st_susfs_sus_path_list *new_list = NULL;
-	struct st_susfs_sus_path info;
+	struct st_susfs_sus_path info = {0};
 	struct path path;
 	struct inode *inode = NULL;
-	char *resolved_pathname = NULL, *tmp_buf = NULL;
-	int err = 0;
 
-	err = copy_from_user(&info, user_info, sizeof(info));
-	if (err) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return err;
+	if (copy_from_user(&info, (struct st_susfs_sus_path __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	err = kern_path(info.target_pathname, 0, &path);
-	if (err) {
+	info.err = kern_path(info.target_pathname, 0, &path);
+	if (info.err) {
 		SUSFS_LOGE("Failed opening file '%s'\n", info.target_pathname);
-		return err;
+		goto out_copy_to_user;
 	}
 
 	if (!path.dentry->d_inode) {
-		err = -EINVAL;
+		info.err = -EINVAL;
 		goto out_path_put_path;
 	}
 	inode = d_inode(path.dentry);
 
-	tmp_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!tmp_buf) {
-		err = -ENOMEM;
-		goto out_path_put_path;
-	}
-
-	resolved_pathname = d_path(&path, tmp_buf, PAGE_SIZE);
-	if (!resolved_pathname) {
-		err = -ENOMEM;
-		goto out_kfree_tmp_buf;
-	}
-
-	if (strstr(resolved_pathname, android_data_path.pathname)) {
+	if (strstr(info.target_pathname, android_data_path.target_pathname)) {
 		if (!android_data_path.is_inited) {
-			err = -EINVAL;
+			info.err = -EINVAL;
 			SUSFS_LOGE("android_data_path is not configured yet, plz do like 'ksu_susfs set_android_data_root_path /sdcard/Android/data' first after your screen is unlocked\n");
-			goto out_kfree_tmp_buf;
-		}
-		list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_ANDROID_DATA, list) {
-			if (unlikely(!strcmp(cursor->info.target_pathname, path.dentry->d_name.name))) {
-				spin_lock(&susfs_spin_lock);
-				cursor->info.target_ino = info.target_ino;
-				strncpy(cursor->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
-				strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
-				cursor->info.i_uid = info.i_uid;
-				cursor->path_len = strlen(cursor->info.target_pathname);
-				SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_ANDROID_DATA\n",
-							cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-				spin_unlock(&susfs_spin_lock);
-				goto out_kfree_tmp_buf;
-			}
+			goto out_path_put_path;
 		}
 		new_list = kmalloc(sizeof(struct st_susfs_sus_path_list), GFP_KERNEL);
 		if (!new_list) {
-			err = -ENOMEM;
-			goto out_kfree_tmp_buf;
+			info.err = -ENOMEM;
+			goto out_path_put_path;
 		}
 		new_list->info.target_ino = info.target_ino;
 		strncpy(new_list->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
-		strncpy(new_list->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
+		strncpy(new_list->target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
 		new_list->info.i_uid = info.i_uid;
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
-		spin_lock(&susfs_spin_lock);
+		spin_lock(&susfs_spin_lock_sus_path);
 		list_add_tail(&new_list->list, &LH_SUS_PATH_ANDROID_DATA);
+		spin_unlock(&susfs_spin_lock_sus_path);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_ANDROID_DATA\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-		spin_unlock(&susfs_spin_lock);
-		goto out_kfree_tmp_buf;
-	} else if (strstr(resolved_pathname, sdcard_path.pathname)) {
+		info.err = 0;
+		goto out_path_put_path;
+	} else if (strstr(info.target_pathname, sdcard_path.target_pathname)) {
 		if (!sdcard_path.is_inited) {
-			err = -EINVAL;
+			info.err = -EINVAL;
 			SUSFS_LOGE("sdcard_path is not configured yet, plz do like 'ksu_susfs set_sdcard_root_path /sdcard' first after your screen is unlocked\n");
-			goto out_kfree_tmp_buf;
-		}
-		list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_SDCARD, list) {
-			if (unlikely(!strcmp(cursor->info.target_pathname, path.dentry->d_name.name))) {
-				spin_lock(&susfs_spin_lock);
-				cursor->info.target_ino = info.target_ino;
-				strncpy(cursor->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
-				strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
-				cursor->info.i_uid = info.i_uid;
-				cursor->path_len = strlen(cursor->info.target_pathname);
-				SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_SDCARD\n",
-							cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-				spin_unlock(&susfs_spin_lock);
-				goto out_kfree_tmp_buf;
-			}
+			goto out_path_put_path;
 		}
 		new_list = kmalloc(sizeof(struct st_susfs_sus_path_list), GFP_KERNEL);
 		if (!new_list) {
-			err = -ENOMEM;
-			goto out_kfree_tmp_buf;
+			info.err = -ENOMEM;
+			goto out_path_put_path;
 		}
 		new_list->info.target_ino = info.target_ino;
 		strncpy(new_list->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
-		strncpy(new_list->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
+		strncpy(new_list->target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
 		new_list->info.i_uid = info.i_uid;
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
-		spin_lock(&susfs_spin_lock);
+		spin_lock(&susfs_spin_lock_sus_path);
 		list_add_tail(&new_list->list, &LH_SUS_PATH_SDCARD);
+		spin_unlock(&susfs_spin_lock_sus_path);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_SDCARD\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-		spin_unlock(&susfs_spin_lock);
-		goto out_kfree_tmp_buf;
+		info.err = 0;
+		goto out_path_put_path;
 	}
 
 	spin_lock(&inode->i_lock);
 	set_bit(AS_FLAGS_SUS_PATH, &inode->i_mapping->flags);
-	SUSFS_LOGI("pathname: '%s', ino: '%lu', is flagged as AS_FLAGS_SUS_PATH\n", resolved_pathname, info.target_ino);
 	spin_unlock(&inode->i_lock);
-out_kfree_tmp_buf:
-	kfree(tmp_buf);
+	SUSFS_LOGI("pathname: '%s', ino: '%lu', is flagged as AS_FLAGS_SUS_PATH\n", info.target_pathname, info.target_ino);
+	info.err = 0;
 out_path_put_path:
 	path_put(&path);
-	return err;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_sus_path __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_ADD_SUS_PATH -> ret: %d\n", info.err);
 }
 
-int susfs_add_sus_path_loop(struct st_susfs_sus_path* __user user_info) {
-	struct st_susfs_sus_path_list *cursor = NULL, *temp = NULL;
+void susfs_add_sus_path_loop(void __user **user_info) {
 	struct st_susfs_sus_path_list *new_list = NULL;
-	struct st_susfs_sus_path info;
+	struct st_susfs_sus_path info = {0};
 	struct path path;
 	struct inode *inode = NULL;
-	char *resolved_pathname = NULL, *tmp_buf = NULL;
-	int err = 0;
 
-	err = copy_from_user(&info, user_info, sizeof(info));
-	if (err) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return err;
+	if (copy_from_user(&info, (struct st_susfs_sus_path __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	err = kern_path(info.target_pathname, 0, &path);
-	if (err) {
+	info.err = kern_path(info.target_pathname, 0, &path);
+	if (info.err) {
 		SUSFS_LOGE("Failed opening file '%s'\n", info.target_pathname);
-		return err;
+		goto out_copy_to_user;
 	}
 
 	if (!path.dentry->d_inode) {
-		err = -EINVAL;
+		info.err = -EINVAL;
 		goto out_path_put_path;
 	}
 	inode = d_inode(path.dentry);
 
-	tmp_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!tmp_buf) {
-		err = -ENOMEM;
+	if (susfs_starts_with(info.target_pathname, "/storage/") ||
+		susfs_starts_with(info.target_pathname, "/sdcard/"))
+	{
+		info.err = -EINVAL;
+		SUSFS_LOGE("path starts with /storage and /sdcard cannot be added by add_sus_path_loop\n");
 		goto out_path_put_path;
 	}
 
-	resolved_pathname = d_path(&path, tmp_buf, PAGE_SIZE);
-	SUSFS_LOGI("resolved_pathname: %s\n", resolved_pathname);
-	if (!resolved_pathname) {
-		err = -ENOMEM;
-		goto out_kfree_tmp_buf;
-	}
-
-	if (susfs_starts_with(resolved_pathname, "/storage/")) {
-		err = -EINVAL;
-		SUSFS_LOGE("path starts with /storage and /sdcard cannot be added by add_sus_path_loop\n");
-		goto out_kfree_tmp_buf;
-	}
-
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_LOOP, list) {
-		if (unlikely(!strcmp(cursor->info.target_pathname, resolved_pathname))) {
-			spin_lock(&susfs_spin_lock);
-			cursor->info.target_ino = info.target_ino;
-			strncpy(cursor->info.target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
-			strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
-			cursor->info.i_uid = info.i_uid;
-			cursor->path_len = strlen(cursor->info.target_pathname);
-			SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_LOOP\n",
-						cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-			spin_unlock(&susfs_spin_lock);
-			goto out_set_sus_path;
-		}
-	}
 	new_list = kmalloc(sizeof(struct st_susfs_sus_path_list), GFP_KERNEL);
 	if (!new_list) {
-		err = -ENOMEM;
-		goto out_kfree_tmp_buf;
+		info.err = -ENOMEM;
+		goto out_path_put_path;
 	}
 	new_list->info.target_ino = info.target_ino;
-	strncpy(new_list->info.target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
-	strncpy(new_list->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
+	strncpy(new_list->info.target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
+	strncpy(new_list->target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
 	new_list->info.i_uid = info.i_uid;
 	new_list->path_len = strlen(new_list->info.target_pathname);
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_path);
 	list_add_tail(&new_list->list, &LH_SUS_PATH_LOOP);
+	spin_unlock(&susfs_spin_lock_sus_path);
 	SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_LOOP\n",
 				new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-	spin_unlock(&susfs_spin_lock);
-out_set_sus_path:
 	spin_lock(&inode->i_lock);
 	set_bit(AS_FLAGS_SUS_PATH, &inode->i_mapping->flags);
-	SUSFS_LOGI("pathname: '%s', ino: '%lu', is flagged as AS_FLAGS_SUS_PATH\n", resolved_pathname, info.target_ino);
 	spin_unlock(&inode->i_lock);
-out_kfree_tmp_buf:
-	kfree(tmp_buf);
+	SUSFS_LOGI("pathname: '%s', ino: '%lu', is flagged as AS_FLAGS_SUS_PATH\n", info.target_pathname, info.target_ino);
+	info.err = 0;
 out_path_put_path:
 	path_put(&path);
-	return err;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_sus_path __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_ADD_SUS_PATH_LOOP -> ret: %d\n", info.err);
 }
 
 void susfs_run_sus_path_loop(uid_t uid) {
-	struct st_susfs_sus_path_list *cursor = NULL, *temp = NULL;
+	struct st_susfs_sus_path_list *cursor = NULL;
 	struct path path;
 	struct inode *inode;
 
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_LOOP, list) {
+	list_for_each_entry(cursor, &LH_SUS_PATH_LOOP, list) {
 		if (!kern_path(cursor->target_pathname, 0, &path)) {
 			inode = path.dentry->d_inode;
 			spin_lock(&inode->i_lock);
@@ -376,13 +293,13 @@ bool susfs_is_base_dentry_sdcard_dir(struct dentry* base) {
 }
 
 bool susfs_is_sus_android_data_d_name_found(const char *d_name) {
-	struct st_susfs_sus_path_list *cursor = NULL, *temp = NULL;
+	struct st_susfs_sus_path_list *cursor = NULL;
 
 	if (d_name[0] == '\0') {
 		return false;
 	}
 
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_ANDROID_DATA, list) {
+	list_for_each_entry(cursor, &LH_SUS_PATH_ANDROID_DATA, list) {
 		// - we use strstr here because we cannot retrieve the dentry of fuse_dentry
 		//   and attacker can still use path travesal attack to detect the path, but
 		//   lucky we can check for the uid so it won't let them fool us
@@ -398,12 +315,12 @@ bool susfs_is_sus_android_data_d_name_found(const char *d_name) {
 }
 
 bool susfs_is_sus_sdcard_d_name_found(const char *d_name) {
-	struct st_susfs_sus_path_list *cursor = NULL, *temp = NULL;
+	struct st_susfs_sus_path_list *cursor = NULL;
 
 	if (d_name[0] == '\0') {
 		return false;
 	}
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_SDCARD, list) {
+	list_for_each_entry(cursor, &LH_SUS_PATH_SDCARD, list) {
 		if (!strncmp(d_name, cursor->info.target_pathname, cursor->path_len) &&
 		    (d_name[cursor->path_len] == '\0' || d_name[cursor->path_len] == '/') &&
 			is_i_uid_in_sdcard_not_allowed())
@@ -451,168 +368,52 @@ bool susfs_is_inode_sus_path(struct inode *inode) {
 
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-static LIST_HEAD(LH_SUS_MOUNT);
-static void susfs_update_sus_mount_inode(char *target_pathname) {
-	struct mount *mnt = NULL;
-	struct path p;
-	struct inode *inode = NULL;
-	int err = 0;
-
-	err = kern_path(target_pathname, 0, &p);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", target_pathname);
-		return;
-	}
-
-	/* It is important to check if the mount has a legit peer group id, if so we cannot add them to sus_mount,
-	 * since there are chances that the mount is a legit mountpoint, and it can be misued by other susfs functions in future.
-	 * And by doing this it won't affect the sus_mount check as other susfs functions check by mnt->mnt_id
-	 * instead of BIT_SUS_MOUNT.
-	 */
-	mnt = real_mount(p.mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
-		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", target_pathname);
-		return;
-	}
-
-	inode = d_inode(p.dentry);
-	if (!inode) {
-		path_put(&p);
-		SUSFS_LOGE("inode is NULL\n");
-		return;
-	}
-
-	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
-		spin_unlock(&inode->i_lock);
-	}
-	path_put(&p);
-}
-
-int susfs_add_sus_mount(struct st_susfs_sus_mount* __user user_info) {
-	struct st_susfs_sus_mount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_sus_mount_list *new_list = NULL;
-	struct st_susfs_sus_mount info;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
-#ifdef CONFIG_MIPS
-	info.target_dev = new_decode_dev(info.target_dev);
-#else
-	info.target_dev = huge_decode_dev(info.target_dev);
-#endif /* CONFIG_MIPS */
-#else
-	info.target_dev = old_decode_dev(info.target_dev);
-#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
-
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_MOUNT, list) {
-		if (unlikely(!strcmp(cursor->info.target_pathname, info.target_pathname))) {
-			spin_lock(&susfs_spin_lock);
-			memcpy(&cursor->info, &info, sizeof(info));
-			susfs_update_sus_mount_inode(cursor->info.target_pathname);
-			SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully updated to LH_SUS_MOUNT\n",
-						cursor->info.target_pathname, cursor->info.target_dev);
-			spin_unlock(&susfs_spin_lock);
-			return 0;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_sus_mount_list), GFP_KERNEL);
-	if (!new_list) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_mount);
+bool susfs_hide_sus_mnts_for_all_procs = true; // hide sus mounts for all processes by default
 
-	memcpy(&new_list->info, &info, sizeof(info));
-	susfs_update_sus_mount_inode(new_list->info.target_pathname);
+void susfs_set_hide_sus_mnts_for_all_procs(void __user **user_info) {
+	struct st_susfs_hide_sus_mnts_for_all_procs info = {0};
 
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_SUS_MOUNT);
-	SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully added to LH_SUS_MOUNT\n",
-				new_list->info.target_pathname, new_list->info.target_dev);
-	spin_unlock(&susfs_spin_lock);
-	return 0;
-}
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-void susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target) {
-	struct mount *mnt;
-	struct inode *inode;
-
-	mnt = real_mount(path_target->mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
-		// return 0 here as we still want it to be added to try_umount list
-		return;
+	if (copy_from_user(&info, (struct st_susfs_hide_sus_mnts_for_all_procs __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
-	inode = path_target->dentry->d_inode;
-	if (!inode) return;
-	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
-		spin_unlock(&inode->i_lock);
-		SUSFS_LOGI("set SUS_MOUNT inode state for source bind mount path '%s'\n", pathname);
+	spin_lock(&susfs_spin_lock_sus_mount);
+	susfs_hide_sus_mnts_for_all_procs = info.enabled;
+	spin_unlock(&susfs_spin_lock_sus_mount);
+	SUSFS_LOGI("susfs_hide_sus_mnts_for_all_procs: %d\n", info.enabled);
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_hide_sus_mnts_for_all_procs __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
 	}
+	SUSFS_LOGI("CMD_SUSFS_HIDE_SUS_MNTS_FOR_ALL_PROCS -> ret: %d\n", info.err);
 }
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
 
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname) {
-	char *pathname = NULL;
-	struct path path;
-	struct inode *inode;
+bool susfs_is_umount_for_zygote_iso_service_enabled = false;
+void susfs_set_umount_for_zygote_iso_service(void __user **user_info) {
+	struct st_susfs_umount_for_zygote_iso_service info = {0};
 
-	pathname = kmalloc(SUSFS_MAX_LEN_PATHNAME, GFP_KERNEL);
-	if (!pathname) {
-		SUSFS_LOGE("no enough memory\n");
-		return;
-	}
-	// Here we need to re-retrieve the struct path as we want the new struct path, not the old one
-	if (strncpy_from_user(pathname, to_pathname, SUSFS_MAX_LEN_PATHNAME-1) < 0) {
-		SUSFS_LOGE("strncpy_from_user()\n");
-		goto out_free_pathname;
-		return;
+	if (copy_from_user(&info, (struct st_susfs_umount_for_zygote_iso_service __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
-	if ((!strncmp(pathname, "/data/adb/modules", 17) ||
-		 !strncmp(pathname, "/debug_ramdisk", 14) ||
-		 !strncmp(pathname, "/system", 7) ||
-		 !strncmp(pathname, "/system_ext", 11) ||
-		 !strncmp(pathname, "/vendor", 7) ||
-		 !strncmp(pathname, "/product", 8) ||
-		 !strncmp(pathname, "/odm", 4)) &&
-		 !kern_path(pathname, LOOKUP_FOLLOW, &path)) {
-		goto set_inode_sus_mount;
-	}
-	goto out_free_pathname;
-set_inode_sus_mount:
-	inode = path.dentry->d_inode;
-	if (!inode) {
-		goto out_path_put;
-		return;
+	spin_lock(&susfs_spin_lock_sus_mount);
+	susfs_is_umount_for_zygote_iso_service_enabled = info.enabled;
+	spin_unlock(&susfs_spin_lock_sus_mount);
+	SUSFS_LOGI("susfs_is_umount_for_zygote_iso_service_enabled: %d\n", info.enabled);
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_umount_for_zygote_iso_service __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
 	}
-	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
-		spin_unlock(&inode->i_lock);
-		SUSFS_LOGI("set SUS_MOUNT inode state for default KSU mount path '%s'\n", pathname);
-	}
-out_path_put:
-	path_put(&path);
-out_free_pathname:
-	kfree(pathname);
+	SUSFS_LOGI("CMD_SUSFS_UMOUNT_FOR_ZYGOTE_ISO_SERVICE -> ret: %d\n", info.err);
 }
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 
 /* sus_kstat */
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_kstat);
 static DEFINE_HASHTABLE(SUS_KSTAT_HLIST, 10);
 static int susfs_update_sus_kstat_inode(char *target_pathname) {
 	struct path p;
@@ -641,38 +442,24 @@ static int susfs_update_sus_kstat_inode(char *target_pathname) {
 	return 0;
 }
 
-int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
-	struct st_susfs_sus_kstat info;
-	struct st_susfs_sus_kstat_hlist *new_entry, *tmp_entry;
-	struct hlist_node *tmp_node;
-	int bkt;
-	bool update_hlist = false;
+void susfs_add_sus_kstat(void __user **user_info) {
+	struct st_susfs_sus_kstat info = {0};
+	struct st_susfs_sus_kstat_hlist *new_entry;
 
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
+	if (copy_from_user(&info, (struct st_susfs_sus_kstat __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
 	if (strlen(info.target_pathname) == 0) {
-		SUSFS_LOGE("target_pathname is an empty string\n");
-		return 1;
+		info.err = -EINVAL;
+		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
-	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
-		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
-			hash_del(&tmp_entry->node);
-			kfree(tmp_entry);
-			update_hlist = true;
-			break;
-		}
-	}
-	spin_unlock(&susfs_spin_lock);
-
 	new_entry = kmalloc(sizeof(struct st_susfs_sus_kstat_hlist), GFP_KERNEL);
 	if (!new_entry) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
+		info.err = -ENOMEM;
+		goto out_copy_to_user;
 	}
 
 #if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
@@ -690,76 +477,63 @@ int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
 
 	if (susfs_update_sus_kstat_inode(new_entry->info.target_pathname)) {
 		kfree(new_entry);
-		return 1;
+		info.err = -EINVAL;
+		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_add(SUS_KSTAT_HLIST, &new_entry->node, info.target_ino);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
-	if (update_hlist) {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%llu', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully added to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
-	} else {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%llu', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully updated to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
-	}
+	SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%llu', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully added to SUS_KSTAT_HLIST\n",
+			new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
+			new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
+			new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
+			new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
+			new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
+			new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
 #else
-	if (update_hlist) {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%u', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully added to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
+	SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%u', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully added to SUS_KSTAT_HLIST\n",
+			new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
+			new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
+			new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
+			new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
+			new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
+			new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
+#endif
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_sus_kstat __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	if (!info.is_statically) {
+		SUSFS_LOGI("CMD_SUSFS_ADD_SUS_KSTAT -> ret: %d\n", info.err);
 	} else {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%u', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully updated to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
+		SUSFS_LOGI("CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY -> ret: %d\n", info.err);
 	}
-#endif
-	spin_unlock(&susfs_spin_lock);
-	return 0;
 }
 
-int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
-	struct st_susfs_sus_kstat info;
+void susfs_update_sus_kstat(void __user **user_info) {
+	struct st_susfs_sus_kstat info = {0};
 	struct st_susfs_sus_kstat_hlist *new_entry, *tmp_entry;
 	struct hlist_node *tmp_node;
 	int bkt;
-	int err = 0;
 
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
+	if (copy_from_user(&info, (struct st_susfs_sus_kstat __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
 	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
 			if (susfs_update_sus_kstat_inode(tmp_entry->info.target_pathname)) {
-				err = 1;
-				goto out_spin_unlock;
+				info.err = -EINVAL;
+				goto out_copy_to_user;
 			}
 			new_entry = kmalloc(sizeof(struct st_susfs_sus_kstat_hlist), GFP_KERNEL);
 			if (!new_entry) {
-				SUSFS_LOGE("no enough memory\n");
-				err = 1;
-				goto out_spin_unlock;
+				info.err = -ENOMEM;
+				goto out_copy_to_user;
 			}
 			memcpy(&new_entry->info, &tmp_entry->info, sizeof(tmp_entry->info));
 			SUSFS_LOGI("updating target_ino from '%lu' to '%lu' for pathname: '%s' in SUS_KSTAT_HLIST\n",
@@ -778,13 +552,18 @@ int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
 			}
 			hash_del(&tmp_entry->node);
 			kfree(tmp_entry);
+			spin_lock(&susfs_spin_lock_sus_kstat);
 			hash_add(SUS_KSTAT_HLIST, &new_entry->node, info.target_ino);
-			goto out_spin_unlock;
+			spin_unlock(&susfs_spin_lock_sus_kstat);
+			info.err = 0;
+			goto out_copy_to_user;
 		}
 	}
-out_spin_unlock:
-	spin_unlock(&susfs_spin_lock);
-	return err;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_sus_kstat __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_UPDATE_SUS_KSTAT -> ret: %d\n", info.err);
 }
 
 void susfs_sus_ino_for_generic_fillattr(unsigned long ino, struct kstat *stat) {
@@ -822,136 +601,23 @@ void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned
 }
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 
-/* try_umount */
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-static LIST_HEAD(LH_TRY_UMOUNT_PATH);
-int susfs_add_try_umount(struct st_susfs_try_umount* __user user_info) {
-	struct st_susfs_try_umount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_try_umount_list *new_list = NULL;
-	struct st_susfs_try_umount info;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	list_for_each_entry_safe(cursor, temp, &LH_TRY_UMOUNT_PATH, list) {
-		if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
-			SUSFS_LOGE("target_pathname: '%s' is already created in LH_TRY_UMOUNT_PATH\n", info.target_pathname);
-			return 1;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_try_umount_list), GFP_KERNEL);
-	if (!new_list) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
-
-	memcpy(&new_list->info, &info, sizeof(info));
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
-	SUSFS_LOGI("target_pathname: '%s', mnt_mode: %d, is successfully added to LH_TRY_UMOUNT_PATH\n", new_list->info.target_pathname, new_list->info.mnt_mode);
-	return 0;
-}
-
-void susfs_try_umount(uid_t target_uid) {
-	struct st_susfs_try_umount_list *cursor = NULL;
-
-	// We should umount in reversed order
-	list_for_each_entry_reverse(cursor, &LH_TRY_UMOUNT_PATH, list) {
-		if (cursor->info.mnt_mode == TRY_UMOUNT_DEFAULT) {
-			try_umount(cursor->info.target_pathname, false, 0, target_uid);
-		} else if (cursor->info.mnt_mode == TRY_UMOUNT_DETACH) {
-			try_umount(cursor->info.target_pathname, false, MNT_DETACH, target_uid);
-		} else {
-			SUSFS_LOGE("failed umounting '%s' for uid: %d, mnt_mode '%d' not supported\n",
-							cursor->info.target_pathname, target_uid, cursor->info.mnt_mode);
-		}
-	}
-}
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-void susfs_auto_add_try_umount_for_bind_mount(struct path *path) {
-	struct st_susfs_try_umount_list *new_list = NULL;
-	char *pathname = NULL, *dpath = NULL;
-	size_t new_pathname_len = 0;
-
-#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-	if (path->dentry->d_inode->i_mapping->flags & BIT_SUS_KSTAT) {
-		SUSFS_LOGI("skip adding path to try_umount list as its inode is flagged INODE_STATE_SUS_KSTAT already\n");
-		return;
-	}
-#endif
-
-	pathname = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!pathname) {
-		SUSFS_LOGE("no enough memory\n");
-		return;
-	}
-
-	dpath = d_path(path, pathname, PAGE_SIZE);
-	if (!dpath) {
-		SUSFS_LOGE("dpath is NULL\n");
-		goto out_free_pathname;
-	}
-
-	// - Important to check if it is from a magic mount, if so, then we need only
-	//   the path which is directory only, others should be skipped.
-	// - We need to strip out "/debug_ramdisk/workdir" here since there will be
-	//   no "/debug_ramdisk/workdir" prefixed in zygote mnt ns
-	if (!strncmp(dpath, "/debug_ramdisk/workdir/", 23)) {
-		if (path->dentry->d_inode && S_ISDIR(path->dentry->d_inode->i_mode)) {
-			new_pathname_len = strlen(dpath) - 22;
-			memmove(dpath, dpath+22, new_pathname_len);
-			*(dpath + new_pathname_len) = '\0';
-			goto add_to_new_list;
-		}
-		goto out_free_pathname;
-	}
-add_to_new_list:
-	new_list = kmalloc(sizeof(struct st_susfs_try_umount_list), GFP_KERNEL);
-	if (!new_list) {
-		SUSFS_LOGE("no enough memory\n");
-		goto out_free_pathname;
-	}
-
-	strncpy(new_list->info.target_pathname, dpath, SUSFS_MAX_LEN_PATHNAME-1);
-
-	new_list->info.mnt_mode = TRY_UMOUNT_DETACH;
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
-	SUSFS_LOGI("target_pathname: '%s', ino: %lu, mnt_mode: %d, is successfully added to LH_TRY_UMOUNT_PATH\n",
-					new_list->info.target_pathname, path->dentry->d_inode->i_ino, new_list->info.mnt_mode);
-out_free_pathname:
-	kfree(pathname);
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-#endif // #ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-
 /* spoof_uname */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-static spinlock_t susfs_uname_spin_lock;
+static DEFINE_SPINLOCK(susfs_spin_lock_set_uname);
 static struct st_susfs_uname my_uname;
 static void susfs_my_uname_init(void) {
 	memset(&my_uname, 0, sizeof(my_uname));
 }
 
-int susfs_set_uname(struct st_susfs_uname* __user user_info) {
-	struct st_susfs_uname info;
+void susfs_set_uname(void __user **user_info) {
+	struct st_susfs_uname info = {0};
 
-	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_uname))) {
-		SUSFS_LOGE("failed copying from userspace.\n");
-		return 1;
+	if (copy_from_user(&info, (struct st_susfs_uname __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_uname_spin_lock);
+	spin_lock(&susfs_spin_lock_set_uname);
 	if (!strcmp(info.release, "default")) {
 		strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
 	} else {
@@ -962,68 +628,104 @@ int susfs_set_uname(struct st_susfs_uname* __user user_info) {
 	} else {
 		strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
 	}
-	spin_unlock(&susfs_uname_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_uname);
 	SUSFS_LOGI("setting spoofed release: '%s', version: '%s'\n",
 				my_uname.release, my_uname.version);
-	return 0;
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_uname __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_SET_UNAME -> ret: %d\n", info.err);
 }
 
 void susfs_spoof_uname(struct new_utsname* tmp) {
-	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_uname_spin_lock)))
+	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_spin_lock_set_uname)))
 		return;
 	strncpy(tmp->release, my_uname.release, __NEW_UTS_LEN);
 	strncpy(tmp->version, my_uname.version, __NEW_UTS_LEN);
 }
 #endif // #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
 
-/* set_log */
+/* enable_log */
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-void susfs_set_log(bool enabled) {
-	spin_lock(&susfs_spin_lock);
-	susfs_is_log_enabled = enabled;
-	spin_unlock(&susfs_spin_lock);
+static DEFINE_SPINLOCK(susfs_spin_lock_enable_log);
+
+void susfs_enable_log(void __user **user_info) {
+	struct st_susfs_log info = {0};
+
+	if (copy_from_user(&info, (struct st_susfs_log __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
+	}
+
+	spin_lock(&susfs_spin_lock_enable_log);
+	susfs_is_log_enabled = info.enabled;
+	spin_unlock(&susfs_spin_lock_enable_log);
 	if (susfs_is_log_enabled) {
 		pr_info("susfs: enable logging to kernel");
 	} else {
 		pr_info("susfs: disable logging to kernel");
 	}
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_log __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_ENABLE_LOG -> ret: %d\n", info.err);
 }
 #endif // #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
 
 /* spoof_cmdline_or_bootconfig */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+static DEFINE_SPINLOCK(susfs_spin_lock_set_cmdline_or_bootconfig);
 static char *fake_cmdline_or_bootconfig = NULL;
-int susfs_set_cmdline_or_bootconfig(char* __user user_fake_cmdline_or_bootconfig) {
-	int res;
+static bool susfs_is_fake_cmdline_or_bootconfig_set = false;
+
+void susfs_set_cmdline_or_bootconfig(void __user **user_info) {
+	struct st_susfs_spoof_cmdline_or_bootconfig *info = (struct st_susfs_spoof_cmdline_or_bootconfig *)kzalloc(sizeof(struct st_susfs_spoof_cmdline_or_bootconfig), GFP_KERNEL);
+	
+	if (!info) {
+		info->err = -ENOMEM;
+		goto out_copy_to_user;
+	}
+
+	if (copy_from_user(info, (struct st_susfs_spoof_cmdline_or_bootconfig __user*)*user_info, sizeof(struct st_susfs_spoof_cmdline_or_bootconfig))) {
+		info->err = -EFAULT;
+		goto out_copy_to_user;
+	}
 
 	if (!fake_cmdline_or_bootconfig) {
-		// 4096 is enough I guess
-		fake_cmdline_or_bootconfig = kmalloc(SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE, GFP_KERNEL);
+		fake_cmdline_or_bootconfig = (char *)kzalloc(SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE, GFP_KERNEL);
 		if (!fake_cmdline_or_bootconfig) {
-			SUSFS_LOGE("no enough memory\n");
-			return -ENOMEM;
+			info->err = -ENOMEM;
+			goto out_copy_to_user;
 		}
 	}
 
-	spin_lock(&susfs_spin_lock);
-	memset(fake_cmdline_or_bootconfig, 0, SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE);
-	res = strncpy_from_user(fake_cmdline_or_bootconfig, user_fake_cmdline_or_bootconfig, SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE-1);
-	spin_unlock(&susfs_spin_lock);
-
-	if (res > 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
-		SUSFS_LOGI("fake_cmdline_or_bootconfig is set, length of string: %lu\n", strlen(fake_cmdline_or_bootconfig));
-#else
-		SUSFS_LOGI("fake_cmdline_or_bootconfig is set, length of string: %u\n", strlen(fake_cmdline_or_bootconfig));
-#endif
-		return 0;
+	spin_lock(&susfs_spin_lock_set_cmdline_or_bootconfig);
+	strncpy(fake_cmdline_or_bootconfig,
+			info->fake_cmdline_or_bootconfig,
+			SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE-1);
+	spin_unlock(&susfs_spin_lock_set_cmdline_or_bootconfig);
+	susfs_is_fake_cmdline_or_bootconfig_set = true;
+	SUSFS_LOGI("fake_cmdline_or_bootconfig is set\n");
+	info->err = 0;
+out_copy_to_user:
+	if (info->err) {
+		susfs_is_fake_cmdline_or_bootconfig_set = false;
+	}
+	if (copy_to_user(&((struct st_susfs_spoof_cmdline_or_bootconfig __user*)*user_info)->err, &info->err, sizeof(info->err))) {
+		info->err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG -> ret: %d\n", info->err);
+	if (info) {
+		kfree(info);
 	}
-	SUSFS_LOGI("failed setting fake_cmdline_or_bootconfig\n");
-	return res;
 }
 
 int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m) {
-	if (fake_cmdline_or_bootconfig != NULL) {
+	if (susfs_is_fake_cmdline_or_bootconfig_set && fake_cmdline_or_bootconfig) {
 		seq_puts(m, fake_cmdline_or_bootconfig);
 		return 0;
 	}
@@ -1033,7 +735,9 @@ int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m) {
 
 /* open_redirect */
 #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
+static DEFINE_SPINLOCK(susfs_spin_lock_open_redirect);
 static DEFINE_HASHTABLE(OPEN_REDIRECT_HLIST, 10);
+
 static int susfs_update_open_redirect_inode(struct st_susfs_open_redirect_hlist *new_entry) {
 	struct path path_target;
 	struct inode *inode_target;
@@ -1048,7 +752,7 @@ static int susfs_update_open_redirect_inode(struct st_susfs_open_redirect_hlist
 	inode_target = d_inode(path_target.dentry);
 	if (!inode_target) {
 		SUSFS_LOGE("inode_target is NULL\n");
-		err = 1;
+		err = -EINVAL;
 		goto out_path_put_target;
 	}
 
@@ -1061,33 +765,19 @@ out_path_put_target:
 	return err;
 }
 
-int susfs_add_open_redirect(struct st_susfs_open_redirect* __user user_info) {
-	struct st_susfs_open_redirect info;
-	struct st_susfs_open_redirect_hlist *new_entry, *tmp_entry;
-	struct hlist_node *tmp_node;
-	int bkt;
-	bool update_hlist = false;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
+void susfs_add_open_redirect(void __user **user_info) {
+	struct st_susfs_open_redirect info = {0};
+	struct st_susfs_open_redirect_hlist *new_entry;
 
-	spin_lock(&susfs_spin_lock);
-	hash_for_each_safe(OPEN_REDIRECT_HLIST, bkt, tmp_node, tmp_entry, node) {
-		if (!strcmp(tmp_entry->target_pathname, info.target_pathname)) {
-			hash_del(&tmp_entry->node);
-			kfree(tmp_entry);
-			update_hlist = true;
-			break;
-		}
+	if (copy_from_user(&info, (struct st_susfs_open_redirect __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
-	spin_unlock(&susfs_spin_lock);
 
 	new_entry = kmalloc(sizeof(struct st_susfs_open_redirect_hlist), GFP_KERNEL);
 	if (!new_entry) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
+		info.err = -ENOMEM;
+		goto out_copy_to_user;
 	}
 
 	new_entry->target_ino = info.target_ino;
@@ -1096,20 +786,21 @@ int susfs_add_open_redirect(struct st_susfs_open_redirect* __user user_info) {
 	if (susfs_update_open_redirect_inode(new_entry)) {
 		SUSFS_LOGE("failed adding path '%s' to OPEN_REDIRECT_HLIST\n", new_entry->target_pathname);
 		kfree(new_entry);
-		return 1;
+		info.err = -EINVAL;
+		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_open_redirect);
 	hash_add(OPEN_REDIRECT_HLIST, &new_entry->node, info.target_ino);
-	if (update_hlist) {
-		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', redirected_pathname: '%s', is successfully updated to OPEN_REDIRECT_HLIST\n",
-				new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);	
-	} else {
-		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' redirected_pathname: '%s', is successfully added to OPEN_REDIRECT_HLIST\n",
-				new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);
+	spin_unlock(&susfs_spin_lock_open_redirect);
+	SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' redirected_pathname: '%s', is successfully added to OPEN_REDIRECT_HLIST\n",
+			new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_open_redirect __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
 	}
-	spin_unlock(&susfs_spin_lock);
-	return 0;
+	SUSFS_LOGI("CMD_SUSFS_ADD_OPEN_REDIRECT -> ret: %d\n", info.err);
 }
 
 struct filename* susfs_get_redirected_path(unsigned long ino) {
@@ -1127,39 +818,66 @@ struct filename* susfs_get_redirected_path(unsigned long ino) {
 
 /* sus_map */
 #ifdef CONFIG_KSU_SUSFS_SUS_MAP
-int susfs_add_sus_map(struct st_susfs_sus_map* __user user_info) {
-	struct st_susfs_sus_map info;
+void susfs_add_sus_map(void __user **user_info) {
+	struct st_susfs_sus_map info = {0};
 	struct path path;
 	struct inode *inode = NULL;
-	int err = 0;
-
-	err = copy_from_user(&info, user_info, sizeof(info));
-	if (err) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return err;
+	if (copy_from_user(&info, (struct st_susfs_sus_map __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	err = kern_path(info.target_pathname, LOOKUP_FOLLOW, &path);
-	if (err) {
+	info.err = kern_path(info.target_pathname, LOOKUP_FOLLOW, &path);
+	if (info.err) {
 		SUSFS_LOGE("Failed opening file '%s'\n", info.target_pathname);
-		return err;
+		goto out_copy_to_user;
 	}
 
 	if (!path.dentry->d_inode) {
-		err = -EINVAL;
+		info.err = -EINVAL;
 		goto out_path_put_path;
 	}
 	inode = d_inode(path.dentry);
 	spin_lock(&inode->i_lock);
 	set_bit(AS_FLAGS_SUS_MAP, &inode->i_mapping->flags);
-	SUSFS_LOGI("pathname: '%s', is flagged as AS_FLAGS_SUS_MAP\n", info.target_pathname);
 	spin_unlock(&inode->i_lock);
+	SUSFS_LOGI("pathname: '%s', is flagged as AS_FLAGS_SUS_MAP\n", info.target_pathname);
+	info.err = 0;
 	out_path_put_path:
 	path_put(&path);
-	return err;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_sus_map __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_ADD_SUS_MAP -> ret: %d\n", info.err);
 }
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_MAP
 
+/* susfs avc log spoofing */
+static DEFINE_SPINLOCK(susfs_spin_lock_set_avc_log_spoofing);
+extern bool susfs_is_avc_log_spoofing_enabled;
+
+void susfs_set_avc_log_spoofing(void __user **user_info) {
+	struct st_susfs_avc_log_spoofing info = {0};
+
+	if (copy_from_user(&info, (struct st_susfs_avc_log_spoofing __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
+	}
+
+	spin_lock(&susfs_spin_lock_set_avc_log_spoofing);
+	susfs_is_avc_log_spoofing_enabled = info.enabled;
+	spin_unlock(&susfs_spin_lock_set_avc_log_spoofing);
+	SUSFS_LOGI("susfs_is_avc_log_spoofing_enabled: %d\n", info.enabled);
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user(&((struct st_susfs_avc_log_spoofing __user*)*user_info)->err, &info.err, sizeof(info.err))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_ENABLE_AVC_LOG_SPOOFING -> ret: %d\n", info.err);
+}
+
+/* get susfs enabled features */
 static int copy_config_to_buf(const char *config_string, char *buf_ptr, size_t *copied_size, size_t bufsize) {
 	size_t tmp_size = strlen(config_string);
 
@@ -1172,106 +890,119 @@ static int copy_config_to_buf(const char *config_string, char *buf_ptr, size_t *
 	return 0;
 }
 
-int susfs_get_enabled_features(char __user* buf, size_t bufsize) {
-	char *kbuf = NULL, *buf_ptr = NULL;
+void susfs_get_enabled_features(void __user **user_info) {
+	struct st_susfs_enabled_features *info = (struct st_susfs_enabled_features *)kzalloc(sizeof(struct st_susfs_enabled_features), GFP_KERNEL);
+	char *buf_ptr = NULL;
 	size_t copied_size = 0;
-	int err = 0;
 
-	kbuf = kzalloc(bufsize, GFP_KERNEL);
-	if (!kbuf) {
-		return -ENOMEM;
+	if (!info) {
+		info->err = -ENOMEM;
+		goto out_copy_to_user;
+	}
+
+	if (copy_from_user(info, (struct st_susfs_enabled_features __user*)*user_info, sizeof(struct st_susfs_enabled_features))) {
+		info->err = -EFAULT;
+		goto out_copy_to_user;
 	}
 
-	buf_ptr = kbuf;
+	buf_ptr = info->enabled_features;
+
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_PATH\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_PATH\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_MOUNT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_MOUNT\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_KSTAT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
-#endif
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_TRY_UMOUNT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_KSTAT\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SPOOF_UNAME\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SPOOF_UNAME\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_ENABLE_LOG\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_ENABLE_LOG\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_OPEN_REDIRECT\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
-#endif
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_SU\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_OPEN_REDIRECT\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
 #ifdef CONFIG_KSU_SUSFS_SUS_MAP
-	err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_MAP\n", buf_ptr, &copied_size, bufsize);
-	if (err) goto out_kfree_kbuf;
-	buf_ptr = kbuf + copied_size;
+	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_MAP\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
+	if (info->err) goto out_copy_to_user;
+	buf_ptr = info->enabled_features + copied_size;
 #endif
-	err = copy_to_user((void __user*)buf, (void *)kbuf, bufsize);
-out_kfree_kbuf:
-	kfree(kbuf);
-	return err;
+
+	info->err = 0;
+out_copy_to_user:
+	if (copy_to_user((struct st_susfs_enabled_features __user*)*user_info, info, sizeof(struct st_susfs_enabled_features))) {
+		info->err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_SHOW_ENABLED_FEATURES -> ret: %d\n", info->err);
+	if (info) {
+		kfree(info);
+	}
 }
 
-/* susfs avc log spoofing */
-void susfs_set_avc_log_spoofing(bool enabled) {
-	spin_lock(&susfs_spin_lock);
-	susfs_is_avc_log_spoofing_enabled = enabled;
-	spin_unlock(&susfs_spin_lock);
-	SUSFS_LOGI("enabled: %d\n", enabled);
+/* show_variant */
+void susfs_show_variant(void __user **user_info) {
+	struct st_susfs_variant info = {0};
+
+	if (copy_from_user(&info, (struct st_susfs_variant __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
+	}
+
+	strncpy(info.susfs_variant, SUSFS_VARIANT, SUSFS_MAX_VARIANT_BUFSIZE-1);
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user((struct st_susfs_variant __user*)*user_info, &info, sizeof(info))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_SHOW_VARIANT -> ret: %d\n", info.err);
+}
+
+/* show version */
+void susfs_show_version(void __user **user_info) {
+	struct st_susfs_version info = {0};
+
+	if (copy_from_user(&info, (struct st_susfs_version __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
+	}
+
+	strncpy(info.susfs_version, SUSFS_VERSION, SUSFS_MAX_VERSION_BUFSIZE-1);
+	info.err = 0;
+out_copy_to_user:
+	if (copy_to_user((struct st_susfs_version __user*)*user_info, &info, sizeof(info))) {
+		info.err = -EFAULT;
+	}
+	SUSFS_LOGI("CMD_SUSFS_SHOW_VERSION -> ret: %d\n", info.err);
 }
 
 /* susfs_init */
 void susfs_init(void) {
-	spin_lock_init(&susfs_spin_lock);
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-	spin_lock_init(&susfs_uname_spin_lock);
 	susfs_my_uname_init();
 #endif
 	SUSFS_LOGI("susfs is initialized! version: " SUSFS_VERSION " \n");
diff --git a/include/linux/susfs.h b/include/linux/susfs.h
index c5b0c9d..1cdecd1 100644
--- a/include/linux/susfs.h
+++ b/include/linux/susfs.h
@@ -8,7 +8,7 @@
 #include <linux/path.h>
 #include <linux/susfs_def.h>
 
-#define SUSFS_VERSION "v1.5.12"
+#define SUSFS_VERSION "v2.0.0"
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
 #define SUSFS_VARIANT "NON-GKI"
 #else
@@ -27,9 +27,10 @@
 /* sus_path */
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 struct st_susfs_sus_path {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned int					 i_uid;
+	unsigned long                           target_ino;
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned int                            i_uid;
+	int                                     err;
 };
 
 struct st_susfs_sus_path_list {
@@ -39,48 +40,52 @@ struct st_susfs_sus_path_list {
 	size_t                           path_len;
 };
 
-struct st_android_data_path {
-	char                             pathname[SUSFS_MAX_LEN_PATHNAME];
-	bool                             is_inited;
+struct st_external_dir {
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	bool                                    is_inited;
+	int                                     cmd;
+	int                                     err;
 };
 
 struct st_sdcard_path {
-	char                             pathname[SUSFS_MAX_LEN_PATHNAME];
-	bool                             is_inited;
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long                           target_dev;
+	int                                     err;
 };
 #endif
 
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-struct st_susfs_sus_mount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           target_dev;
+struct st_susfs_hide_sus_mnts_for_all_procs {
+	bool                                    enabled;
+	int                                     err;
 };
 
-struct st_susfs_sus_mount_list {
-	struct list_head                        list;
-	struct st_susfs_sus_mount               info;
+struct st_susfs_umount_for_zygote_iso_service {
+	bool                                    enabled;
+	int                                     err;
 };
 #endif
 
 /* sus_kstat */
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 struct st_susfs_sus_kstat {
-	int                     is_statically;
-	unsigned long           target_ino; // the ino after bind mounted or overlayed
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           spoofed_ino;
-	unsigned long           spoofed_dev;
-	unsigned int            spoofed_nlink;
-	long long               spoofed_size;
-	long                    spoofed_atime_tv_sec;
-	long                    spoofed_mtime_tv_sec;
-	long                    spoofed_ctime_tv_sec;
-	long                    spoofed_atime_tv_nsec;
-	long                    spoofed_mtime_tv_nsec;
-	long                    spoofed_ctime_tv_nsec;
-	unsigned long           spoofed_blksize;
-	unsigned long long      spoofed_blocks;
+	int                                     is_statically;
+	unsigned long                           target_ino; // the ino after bind mounted or overlayed
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long                           spoofed_ino;
+	unsigned long                           spoofed_dev;
+	unsigned int                            spoofed_nlink;
+	long long                               spoofed_size;
+	long                                    spoofed_atime_tv_sec;
+	long                                    spoofed_mtime_tv_sec;
+	long                                    spoofed_ctime_tv_sec;
+	long                                    spoofed_atime_tv_nsec;
+	long                                    spoofed_mtime_tv_nsec;
+	long                                    spoofed_ctime_tv_nsec;
+	unsigned long                           spoofed_blksize;
+	unsigned long long                      spoofed_blocks;
+	int                                     err;
 };
 
 struct st_susfs_sus_kstat_hlist {
@@ -90,101 +95,131 @@ struct st_susfs_sus_kstat_hlist {
 };
 #endif
 
-/* try_umount */
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-struct st_susfs_try_umount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	int                     mnt_mode;
+/* spoof_uname */
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+struct st_susfs_uname {
+	char                                    release[__NEW_UTS_LEN+1];
+	char                                    version[__NEW_UTS_LEN+1];
+	int                                     err;
 };
+#endif
 
-struct st_susfs_try_umount_list {
-	struct list_head                        list;
-	struct st_susfs_try_umount              info;
+/* enable_log */
+#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+struct st_susfs_log {
+	bool                                    enabled;
+	int                                     err;
 };
 #endif
 
-/* spoof_uname */
-#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-struct st_susfs_uname {
-	char        release[__NEW_UTS_LEN+1];
-	char        version[__NEW_UTS_LEN+1];
+/* spoof_cmdline_or_bootconfig */
+#ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+struct st_susfs_spoof_cmdline_or_bootconfig {
+	char                                    fake_cmdline_or_bootconfig[SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE];
+	int                                     err;
 };
 #endif
 
 /* open_redirect */
 #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
 struct st_susfs_open_redirect {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	char                             redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
+	unsigned long                           target_ino;
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	char                                    redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
+	int                                     err;
 };
 
 struct st_susfs_open_redirect_hlist {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	char                             redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
-	struct hlist_node                node;
+	unsigned long                           target_ino;
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	char                                    redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
+	struct hlist_node                       node;
 };
 #endif
 
 /* sus_map */
 #ifdef CONFIG_KSU_SUSFS_SUS_MAP
 struct st_susfs_sus_map {
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	char                                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	int                                     err;
 };
 #endif
 
+/* avc log spoofing */
+struct st_susfs_avc_log_spoofing {
+	bool                                    enabled;
+	int                                     err;
+};
+
+/* get enabled features */
+struct st_susfs_enabled_features {
+	char                                    enabled_features[SUSFS_ENABLED_FEATURES_SIZE];
+	int                                     err;
+};
+
+/* show variant */
+struct st_susfs_variant {
+	char                                    susfs_variant[16];
+	int                                     err;
+};
+
+/* show version */
+struct st_susfs_version {
+	char                                    susfs_version[16];
+	int                                     err;
+};
+
 /***********************/
 /* FORWARD DECLARATION */
 /***********************/
 /* sus_path */
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
-int susfs_set_i_state_on_external_dir(char __user* user_info, int cmd);
-int susfs_add_sus_path(struct st_susfs_sus_path* __user user_info);
+void susfs_set_i_state_on_external_dir(void __user **user_info);
+void susfs_add_sus_path(void __user **user_info);
+void susfs_add_sus_path_loop(void __user **user_info);
 #endif
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-int susfs_add_sus_mount(struct st_susfs_sus_mount* __user user_info);
+void susfs_set_hide_sus_mnts_for_all_procs(void __user **user_info);
+void susfs_set_umount_for_zygote_iso_service(void __user **user_info);
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 
 /* sus_kstat */
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info);
-int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info);
+void susfs_add_sus_kstat(void __user **user_info);
+void susfs_update_sus_kstat(void __user **user_info);
 void susfs_sus_ino_for_generic_fillattr(unsigned long ino, struct kstat *stat);
 void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned long *out_ino);
 #endif
-/* try_umount */
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-int susfs_add_try_umount(struct st_susfs_try_umount* __user user_info);
-void susfs_try_umount(uid_t target_uid);
-#endif // #ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
 /* spoof_uname */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-int susfs_set_uname(struct st_susfs_uname* __user user_info);
+void susfs_set_uname(void __user **user_info);
 void susfs_spoof_uname(struct new_utsname* tmp);
 #endif
-/* set_log */
+/* enable_log */
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-void susfs_set_log(bool enabled);
+void susfs_enable_log(void __user **user_info);
 #endif
 /* spoof_cmdline_or_bootconfig */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
-int susfs_set_cmdline_or_bootconfig(char* __user user_fake_boot_config);
+void susfs_set_cmdline_or_bootconfig(void __user **user_info);
 int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m);
 #endif
 /* open_redirect */
 #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
-int susfs_add_open_redirect(struct st_susfs_open_redirect* __user user_info);
+void susfs_add_open_redirect(void __user **user_info);
 struct filename* susfs_get_redirected_path(unsigned long ino);
 #endif
 /* sus_map */
 #ifdef CONFIG_KSU_SUSFS_SUS_MAP
-int susfs_add_sus_map(struct st_susfs_sus_map* __user user_info);
+void susfs_add_sus_map(void __user **user_info);
 #endif
 
-int susfs_get_enabled_features(char __user* buf, size_t bufsize);
-void susfs_set_avc_log_spoofing(bool enabled);
+void susfs_set_avc_log_spoofing(void __user **user_info);
+
+void susfs_get_enabled_features(void __user **user_info);
+void susfs_show_variant(void __user **user_info);
+void susfs_show_version(void __user **user_info);
 
 /* susfs_init */
 void susfs_init(void);
diff --git a/include/linux/susfs_def.h b/include/linux/susfs_def.h
index e94d558..16cdc62 100644
--- a/include/linux/susfs_def.h
+++ b/include/linux/susfs_def.h
@@ -7,17 +7,18 @@
 /* ENUM */
 /********/
 /* shared with userspace ksu_susfs tool */
+#define SUSFS_MAGIC 0xFAFAFAFA
 #define CMD_SUSFS_ADD_SUS_PATH 0x55550
 #define CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH 0x55551
 #define CMD_SUSFS_SET_SDCARD_ROOT_PATH 0x55552
 #define CMD_SUSFS_ADD_SUS_PATH_LOOP 0x55553
-#define CMD_SUSFS_ADD_SUS_MOUNT 0x55560
+#define CMD_SUSFS_ADD_SUS_MOUNT 0x55560 /* deprecated */
 #define CMD_SUSFS_HIDE_SUS_MNTS_FOR_ALL_PROCS 0x55561
 #define CMD_SUSFS_UMOUNT_FOR_ZYGOTE_ISO_SERVICE 0x55562
 #define CMD_SUSFS_ADD_SUS_KSTAT 0x55570
 #define CMD_SUSFS_UPDATE_SUS_KSTAT 0x55571
 #define CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY 0x55572
-#define CMD_SUSFS_ADD_TRY_UMOUNT 0x55580
+#define CMD_SUSFS_ADD_TRY_UMOUNT 0x55580 /* deprecated */
 #define CMD_SUSFS_SET_UNAME 0x55590
 #define CMD_SUSFS_ENABLE_LOG 0x555a0
 #define CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG 0x555b0
@@ -30,7 +31,10 @@
 #define CMD_SUSFS_ADD_SUS_MAP 0x60020
 
 #define SUSFS_MAX_LEN_PATHNAME 256 // 256 should address many paths already unless you are doing some strange experimental stuff, then set your own desired length
-#define SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE 4096
+#define SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE 8192 // 8192 is enough I guess
+#define SUSFS_ENABLED_FEATURES_SIZE 8192 // 8192 is enough I guess
+#define SUSFS_MAX_VERSION_BUFSIZE 16
+#define SUSFS_MAX_VARIANT_BUFSIZE 16
 
 #define TRY_UMOUNT_DEFAULT 0 /* used by susfs_try_umount() */
 #define TRY_UMOUNT_DETACH 1 /* used by susfs_try_umount() */
@@ -42,7 +46,7 @@
 /*
  * inode->i_state => storing flag 'INODE_STATE_'
  * mount->mnt.susfs_mnt_id_backup => storing original mount's mnt_id
- * inode->i_mapping->flags => storing flag 'AS_FLAGS_'
+ * inode->i_mapping->flags => A 'unsigned long' type storing flag 'AS_FLAGS_', bit 1 to 31 is not usable since 6.12
  * nd->state => storing flag 'ND_STATE_'
  * nd->flags => storing flag 'ND_FLAGS_'
  * task_struct->thread_info.flags => storing flag 'TIF_'
@@ -50,20 +54,20 @@
 
 #define TIF_PROC_UMOUNTED 33
 
-#define AS_FLAGS_SUS_PATH 24
-#define AS_FLAGS_SUS_MOUNT 25
-#define AS_FLAGS_SUS_KSTAT 26
-#define AS_FLAGS_OPEN_REDIRECT 27
-#define AS_FLAGS_ANDROID_DATA_ROOT_DIR 28
-#define AS_FLAGS_SDCARD_ROOT_DIR 29
-#define AS_FLAGS_SUS_MAP 30
-#define BIT_SUS_PATH BIT(24)
-#define BIT_SUS_MOUNT BIT(25)
-#define BIT_SUS_KSTAT BIT(26)
-#define BIT_OPEN_REDIRECT BIT(27)
-#define BIT_ANDROID_DATA_ROOT_DIR BIT(28)
-#define BIT_ANDROID_SDCARD_ROOT_DIR BIT(29)
-#define BIT_SUS_MAPS BIT(30)
+#define AS_FLAGS_SUS_PATH 33
+#define AS_FLAGS_SUS_MOUNT 34
+#define AS_FLAGS_SUS_KSTAT 35
+#define AS_FLAGS_OPEN_REDIRECT 36
+#define AS_FLAGS_ANDROID_DATA_ROOT_DIR 37
+#define AS_FLAGS_SDCARD_ROOT_DIR 38
+#define AS_FLAGS_SUS_MAP 39
+#define BIT_SUS_PATH BIT(33)
+#define BIT_SUS_MOUNT BIT(34)
+#define BIT_SUS_KSTAT BIT(35)
+#define BIT_OPEN_REDIRECT BIT(36)
+#define BIT_ANDROID_DATA_ROOT_DIR BIT(37)
+#define BIT_ANDROID_SDCARD_ROOT_DIR BIT(38)
+#define BIT_SUS_MAPS BIT(39)
 
 #define ND_STATE_LOOKUP_LAST 32
 #define ND_STATE_OPEN_LAST 64
@@ -71,10 +75,6 @@
 #define ND_FLAGS_LOOKUP_LAST		0x2000000
 
 #define MAGIC_MOUNT_WORKDIR "/debug_ramdisk/workdir"
-#define DATA_ADB_UMOUNT_FOR_ZYGOTE_SYSTEM_PROCESS "/data/adb/susfs_umount_for_zygote_system_process"
-#define DATA_ADB_NO_AUTO_ADD_SUS_BIND_MOUNT "/data/adb/susfs_no_auto_add_sus_bind_mount"
-#define DATA_ADB_NO_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT "/data/adb/susfs_no_auto_add_sus_ksu_default_mount"
-#define DATA_ADB_NO_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT "/data/adb/susfs_no_auto_add_try_umount_for_bind_mount"
 
 static inline bool susfs_is_current_proc_umounted(void) {
 	return test_ti_thread_flag(&current->thread_info, TIF_PROC_UMOUNTED);
diff --git a/security/selinux/avc.c b/security/selinux/avc.c
index efc2cdd..6b33649 100644
--- a/security/selinux/avc.c
+++ b/security/selinux/avc.c
@@ -695,7 +695,7 @@ static void avc_audit_pre_callback(struct audit_buffer *ab, void *a)
 }
 #ifdef CONFIG_KSU_SUSFS
 extern u32 susfs_ksu_sid;
-extern u32 susfs_kernel_sid;
+extern u32 susfs_priv_app_sid;
 bool susfs_is_avc_log_spoofing_enabled = false;
 #endif
 
@@ -725,11 +725,11 @@ static void avc_audit_post_callback(struct audit_buffer *ab, void *a)
 	rc = security_sid_to_context(sad->state, sad->tsid, &scontext,
 				     &scontext_len);
 #ifdef CONFIG_KSU_SUSFS
-	if (unlikely(sad->tsid == susfs_ksu_sid)) {
+	if (unlikely(sad->tsid == susfs_ksu_sid && susfs_is_avc_log_spoofing_enabled)) {
 		if (rc)
-			audit_log_format(ab, " tsid=%d", susfs_kernel_sid && susfs_is_avc_log_spoofing_enabled);
+			audit_log_format(ab, " tsid=%d", susfs_priv_app_sid);
 		else
-			audit_log_format(ab, " tcontext=%s", "u:r:kernel:s0");
+			audit_log_format(ab, " tcontext=%s", "u:r:priv_app:s0:c512,c768");
 		goto bypass_orig_flow;
 	}
 #endif
